/* Smack C++ @ https://github.com/smacklib/dev_smack_cpp
 *
 * Tests.
 *
 * Copyright © 2019-2025 Michael Binz
 */

#pragma once

#include <memory>
#include <mutex>
#include <stdexcept>
#include <string>
#include <string_view>

namespace smack::localisation {

/**
 * Represents a simplified locale consisting of an ISO-3166-1 alpha-3 country
 * code and an ISO-639-3 language code.  The language code is optional.
 *
 * External notation as generated by the \b toString operation is
 * 'language_country', if no country is given only 'language'.
 */
class Locale final {

    /**
     * ISO-639-3
     *
     * Example: 'deu'
     */
    const std::string language_;

    /**
     * ISO-3166-1 alpha-3
     *
     * Example: 'DEU'
     */
    const std::string country_;

    /**
     * The currently set locale.
     *
     * Implementation note: This is kept as a dynamically allocated
     * element because of clang-tidy message [cert-err58-cpp].
     */
    static std::unique_ptr<Locale> s_current;

    /**
     * A mutex that needs to be locked by the static operations.
     */
    static std::mutex s_current_mutex;

public:
    /**
     * Creates a default locale with an empty country and language.
     */
    Locale()
    {
    }

    /**
     * Create an instance.
     *
     * @param isoLanguage The iso language code.
     * @param isoCountry The iso country code.  Defaults to the empty string.
     * @throws std::invalid_argument If isoLanguage is the empty string, or if
     * isoCountry or isoLanguage contain the '_'-character.
     */
    Locale(std::string_view isoLanguage, std::string_view isoCountry = "")
        : language_{isoLanguage}
        , country_{isoCountry}
    {
        if (country_.find_first_of("_") != std::string::npos) {
            throw std::invalid_argument("isoCountry contains '_'.");
        }
        if (language_.find_first_of("_") != std::string::npos) {
            throw std::invalid_argument("isoLanguage contains '_'.");
        }
    }

    ~Locale() = default;

    /**
     * Get the Locale-name properly concatenated.  The order is
     * language[_country].
     * Example 'deu_DEU' or 'deu'.
     */
    auto toString() const -> std::string
    {
        if (country_.empty()) {
            return language_;
        }

        return language_ + "_" + country_;
    }

    /**
     * Get the country.  For the fallback locale this may be the empty
     * string.
     */
    auto getCountry() const -> std::string
    {
        return country_;
    }

    /**
     * Get the language. May be the empty string if none is set.
     */
    auto getLanguage() const -> std::string
    {
        return language_;
    }

    /**
     * Get the currently active locale.
     */
    static auto getCurrent() -> Locale
    {
        std::lock_guard<std::mutex> lock(s_current_mutex);

        if (s_current == nullptr) {
            s_current = std::make_unique<Locale>();
        }

        return *s_current;
    }

    /**
     * Support std::set<Locale>.
     */
    bool operator<(const Locale& r) const
    {
        return toString() < r.toString();
    }

    /**
     * Support std::set<Locale>.
     */
    bool operator==(const Locale& r) const
    {
        return toString() == r.toString();
    }

    /**
     * Set the currently active locale.  This is intended as the interface
     * to a system that knows the current locale and can set it properly.
     */
    static auto setCurrent(const Locale& locale) -> void
    {
        std::lock_guard<std::mutex> lock(s_current_mutex);

        s_current = std::make_unique<Locale>(locale.language_, locale.country_);
    }
};

} // namespace smack::localisation
